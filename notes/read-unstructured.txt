package main

import (
	"context"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"time"

	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/util/yaml"
	"k8s.io/client-go/dynamic"
	"k8s.io/client-go/discovery"
	"k8s.io/client-go/restmapper"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/util/homedir"
	"sigs.k8s.io/controller-runtime/pkg/client/config"
)

type snapshot struct {
	key  schema.GroupVersionResource
	ns   string
	name string
	obj  *unstructured.Unstructured
}

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Usage: atomic-apply manifest.yaml")
		os.Exit(1)
	}

	manifestPath := os.Args[1]
	manifestBytes, err := ioutil.ReadFile(manifestPath)
	check(err)

	cfg, err := config.GetConfig()
	check(err)

	dyn, err := dynamic.NewForConfig(cfg)
	check(err)

	discoveryClient, err := discovery.NewDiscoveryClientForConfig(cfg)
	check(err)

	restMapper := restmapper.NewDeferredDiscoveryRESTMapper(memoryCachedDiscovery{discoveryClient})
	objs := readManifests(manifestBytes)

	var prev []snapshot

	ctx := context.Background()
	for _, obj := range objs {
		mapping, err := restMapper.RESTMapping(obj.GroupVersionKind().GroupKind(), obj.GroupVersionKind().Version)
		check(err)

		resource := dyn.Resource(mapping.Resource).Namespace(obj.GetNamespace())

		// Try to get existing object
		existing, err := resource.Get(ctx, obj.GetName(), metav1.GetOptions{})
		if err == nil {
			prev = append(prev, snapshot{
				key:  mapping.Resource,
				ns:   obj.GetNamespace(),
				name: obj.GetName(),
				obj:  existing.DeepCopy(),
			})
			_, err = resource.Update(ctx, obj, metav1.UpdateOptions{})
		} else {
			_, err = resource.Create(ctx, obj, metav1.CreateOptions{})
		}
		if err != nil {
			fmt.Printf("Apply failed for %s/%s: %v\n", obj.GetKind(), obj.GetName(), err)
			rollback(ctx, dyn, prev)
			os.Exit(1)
		}
	}

	// Wait for readiness
	for _, obj := range objs {
		err := waitForReady(ctx, dyn, restMapper, obj, 30*time.Second)
		if err != nil {
			fmt.Printf("Timeout waiting for %s/%s to be ready: %v\n", obj.GetKind(), obj.GetName(), err)
			rollback(ctx, dyn, prev)
			os.Exit(1)
		}
	}

	fmt.Println("All resources applied and ready.")
}

func readManifests(data []byte) []*unstructured.Unstructured {
	decoder := yaml.NewYAMLOrJSONDecoder(filepath.NewReader(filepath.Clean("/dev/stdin")), 4096)
	docs := []*unstructured.Unstructured{}

	for {
		u := &unstructured.Unstructured{}
		err := decoder.Decode(u)
		if err != nil {
			break
		}
		if u.Object == nil {
			continue
		}
		docs = append(docs, u)
	}
	return docs
}

func rollback(ctx context.Context, dyn dynamic.Interface, prev []snapshot) {
	fmt.Println("Rolling back...")
	for _, snap := range prev {
		res := dyn.Resource(snap.key).Namespace(snap.ns)
		_, err := res.Update(ctx, snap.obj, metav1.UpdateOptions{})
		if err != nil {
			fmt.Printf("Failed to rollback %s/%s: %v\n", snap.key.Resource, snap.name, err)
		} else {
			fmt.Printf("Rolled back %s/%s\n", snap.key.Resource, snap.name)
		}
	}
}

func waitForReady(ctx context.Context, dyn dynamic.Interface, rm meta.RESTMapper, obj *unstructured.Unstructured, timeout time.Duration) error {
	gvk := obj.GroupVersionKind()
	mapping, err := rm.RESTMapping(gvk.GroupKind(), gvk.Version)
	if err != nil {
		return err
	}
	res := dyn.Resource(mapping.Resource).Namespace(obj.GetNamespace())
	start := time.Now()

	for time.Since(start) < timeout {
		updated, err := res.Get(ctx, obj.GetName(), metav1.GetOptions{})
		if err != nil {
			return err
		}
		conds, found, _ := unstructured.NestedSlice(updated.Object, "status", "conditions")
		if found {
			for _, cond := range conds {
				m, ok := cond.(map[string]interface{})
				if ok && m["type"] == "Available" && m["status"] == "True" {
					return nil
				}
			}
		}
		time.Sleep(2 * time.Second)
	}
	return fmt.Errorf("timeout exceeded")
}

// dummy wrapper to enable caching
type memoryCachedDiscovery struct {
	delegate discovery.DiscoveryInterface
}

func (c memoryCachedDiscovery) Fresh() bool                                           { return false }
func (c memoryCachedDiscovery) Invalidate()                                           {}
func (c memoryCachedDiscovery) ServerGroups() (*metav1.APIGroupList, error)           { return c.delegate.ServerGroups() }
func (c memoryCachedDiscovery) ServerResourcesForGroupVersion(groupVersion string) (*metav1.APIResourceList, error) {
	return c.delegate.ServerResourcesForGroupVersion(groupVersion)
}
func (c memoryCachedDiscovery) ServerGroupsAndResources() ([]*metav1.APIGroup, []*metav1.APIResourceList, error) {
	return c.delegate.ServerGroupsAndResources()
}
func (c memoryCachedDiscovery) ServerPreferredResources() ([]*metav1.APIResourceList, error) {
	return c.delegate.ServerPreferredResources()
}
func (c memoryCachedDiscovery) ServerPreferredNamespacedResources() ([]*metav1.APIResourceList, error) {
	return c.delegate.ServerPreferredNamespacedResources()
}
func (c memoryCachedDiscovery) ServerVersion() (*metav1.Info, error) {
	return c.delegate.ServerVersion()
}

func check(err error) {
	if err != nil {
		fmt.Fprintf(os.Stderr, "Fatal: %v\n", err)
		os.Exit(1)
	}
}

