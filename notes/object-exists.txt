package main

import (
	"context"
	"fmt"
	"k8s.io/client-go/rest"
	"os"
	"strings"

	"k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/meta"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/apimachinery/pkg/runtime/serializer/yaml"
	"k8s.io/client-go/discovery"
	"k8s.io/client-go/discovery/cached/memory"
	"k8s.io/client-go/dynamic"
	"k8s.io/client-go/restmapper"
	"k8s.io/client-go/tools/clientcmd"
)

var dec = yaml.NewDecodingSerializer(unstructured.UnstructuredJSONScheme)

func main() {
	cfg, err := rest.InClusterConfig()
	if err != nil {
		cfg, err = clientcmd.BuildConfigFromFlags("", clientcmd.RecommendedHomeFile)
		must(err)
	}

	dyn, err := dynamic.NewForConfig(cfg) // dynamic client
	must(err)
	disco, err := discovery.NewDiscoveryClientForConfig(cfg)
	must(err)

	// A RESTMapper that lazy-refreshes & caches discovery
	mapper := restmapper.NewDeferredDiscoveryRESTMapper(
		memory.NewMemCacheClient(disco))

	// ---------- read & split YAML -----------
	docBytes, _ := os.ReadFile("testdata/nginx.yaml")
	docs := strings.Split(string(docBytes), "\n---")

	for _, d := range docs {
		d = strings.TrimSpace(d)
		if d == "" {
			continue
		}
		obj := &unstructured.Unstructured{}
		_, gvk, err := dec.Decode([]byte(d), nil, obj)
		must(err)

		if exists, err := objectExists(context.TODO(), mapper, dyn, obj, *gvk, "default"); err != nil {
			fmt.Printf("⚠ %s/%s — error: %v\n", obj.GetKind(), obj.GetName(), err)
		} else if exists {
			fmt.Printf("✔ %s/%s already present\n", obj.GetKind(), obj.GetName())
		} else {
			fmt.Printf("✘ %s/%s NOT present\n", obj.GetKind(), obj.GetName())
		}
	}
}

/*
objectExists returns true if an object with the same kind/GVK, name and
namespace is already in the cluster.
If the RESTMapper can’t resolve the GVK (e.g. a CRD hasn’t been
installed yet) it returns an error so the caller can decide what to do.
*/
func objectExists(
	ctx context.Context,
	mapper *restmapper.DeferredDiscoveryRESTMapper,
	dyn dynamic.Interface,
	obj *unstructured.Unstructured,
	gvk schema.GroupVersionKind,
	defaultNS string,
) (bool, error) {

	// Map GVK → GVR (resource endpoint)
	mapping, err := mapper.RESTMapping(gvk.GroupKind(), gvk.Version)
	if err != nil {
		// Could be because discovery cache is stale or the CRD isn’t installed
		mapper.Reset() // invalidate cache & retry once
		mapping, err = mapper.RESTMapping(gvk.GroupKind(), gvk.Version)
		if err != nil {
			return false, fmt.Errorf("no mapping for %s: %w", gvk.String(), err)
		}
	}
	gvr := mapping.Resource

	var dr dynamic.ResourceInterface
	if mapping.Scope.Name() == meta.RESTScopeNameNamespace {
		ns := obj.GetNamespace()
		if ns == "" {
			ns = defaultNS
		}
		dr = dyn.Resource(gvr).Namespace(ns)
	} else {
		dr = dyn.Resource(gvr)
	}

	_, err = dr.Get(ctx, obj.GetName(), metav1.GetOptions{})
	if errors.IsNotFound(err) {
		return false, nil
	}
	return err == nil, err
}

func must(err error) {
	if err != nil {
		panic(err)
	}
}
