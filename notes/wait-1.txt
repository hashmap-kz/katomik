
/* ---- readiness (very short) ---- */
func waitReady(plan []applyItem, to time.Duration) error {
	ctx, cancel := context.WithTimeout(context.Background(), to)
	defer cancel()
	var checks []func() (bool, error)
	for _, p := range plan {
		kind := strings.ToLower(p.obj.GetKind())
		name := p.obj.GetName()
		switch kind {
		case "deployment":
			checks = append(checks, func() (bool, error) {
				o, err := p.dr.Get(ctx, name, metav1.GetOptions{})
				if err != nil {
					return false, err
				}

				gen, _, _ := unstructured.NestedInt64(o.Object, "metadata", "generation")
				obs, _, _ := unstructured.NestedInt64(o.Object, "status", "observedGeneration")

				want, _, _ := unstructured.NestedInt64(o.Object, "spec", "replicas")
				updated, _, _ := unstructured.NestedInt64(o.Object, "status", "updatedReplicas")
				total, _, _ := unstructured.NestedInt64(o.Object, "status", "replicas")
				avail, _, _ := unstructured.NestedInt64(o.Object, "status", "availableReplicas")

				if want == 0 {
					want = 1
				} // default when .spec.replicas omitted

				progressOk := (gen == obs) &&
					(updated == want) &&
					(total == want) &&
					(avail == want)

				// Fast-fail if the controller already declared the rollout dead
				if conds, _, _ := unstructured.NestedSlice(o.Object, "status", "conditions"); conds != nil {
					for _, c := range conds {
						if m, ok := c.(map[string]interface{}); ok &&
							m["type"] == "Progressing" &&
							m["reason"] == "ProgressDeadlineExceeded" {
							return false, fmt.Errorf("deployment %s stalled", name)
						}
					}
				}
				return progressOk, nil
			})

		case "statefulset":
			checks = append(checks, func() (bool, error) {
				o, err := p.dr.Get(ctx, name, metav1.GetOptions{})
				if err != nil {
					return false, err
				}
				ready, _, _ := unstructured.NestedInt64(o.Object, "status", "readyReplicas")
				want, _, _ := unstructured.NestedInt64(o.Object, "spec", "replicas")
				return ready >= want, nil
			})
		case "job":
			checks = append(checks, func() (bool, error) {
				o, err := p.dr.Get(ctx, name, metav1.GetOptions{})
				if err != nil {
					return false, err
				}
				succ, _, _ := unstructured.NestedInt64(o.Object, "status", "succeeded")
				comp, _, _ := unstructured.NestedInt64(o.Object, "spec", "completions")
				return (comp == 0 && succ > 0) || succ >= comp, nil
			})
		}
	}
	return wait.PollUntilContextCancel(ctx, 2*time.Second, true,
		func(ctx context.Context) (bool, error) {
			for _, f := range checks {
				ok, err := f()
				if err != nil || !ok {
					return false, err
				}
			}
			return true, nil
		})
}
